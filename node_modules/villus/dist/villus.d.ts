import { TypedDocumentNode } from '@graphql-typed-document-node/core';
import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';
import * as vue from 'vue';
import { Ref, App, InjectionKey } from 'vue';

interface GraphQLResponse<TData> {
    data: TData;
    errors: any;
}
interface FetchOptions extends RequestInit {
    url?: string;
    headers: NonNullable<Record<string, string>>;
}
interface ParsedResponse<TData> {
    ok: boolean;
    status: number;
    statusText: string;
    headers: Headers;
    body: GraphQLResponse<TData> | null;
}
interface Operation<TData, TVars> {
    query: string | DocumentNode | TypedDocumentNode<TData, TVars>;
    variables?: TVars;
}

declare function parseResponse<TData>(response: Response): Promise<ParsedResponse<TData>>;
declare function mergeFetchOpts(lhs: FetchOptions, rhs: FetchOptions): {
    method: string;
    headers: {
        [x: string]: string;
    };
    url?: string;
    body?: BodyInit;
    cache?: RequestCache;
    credentials?: RequestCredentials;
    integrity?: string;
    keepalive?: boolean;
    mode?: RequestMode;
    redirect?: RequestRedirect;
    referrer?: string;
    referrerPolicy?: ReferrerPolicy;
    signal?: AbortSignal;
    window?: null;
};
declare function makeFetchOptions({ query, variables }: Operation<unknown, unknown>, opts: FetchOptions): {
    method: string;
    headers: {
        [x: string]: string;
    };
    url?: string;
    body?: BodyInit;
    cache?: RequestCache;
    credentials?: RequestCredentials;
    integrity?: string;
    keepalive?: boolean;
    mode?: RequestMode;
    redirect?: RequestRedirect;
    referrer?: string;
    referrerPolicy?: ReferrerPolicy;
    signal?: AbortSignal;
    window?: null;
};

declare class CombinedError extends Error {
    name: 'CombinedError';
    message: string;
    response: any;
    networkError?: Error;
    graphqlErrors?: GraphQLError[];
    constructor({ response, networkError, graphqlErrors, }: {
        response: any;
        networkError?: Error;
        graphqlErrors?: Array<string | GraphQLError | Error>;
    });
    get isGraphQLError(): boolean;
    toString(): string;
}

interface OperationResult<TData = any> {
    data: TData | null;
    error: CombinedError | null;
}
declare type CachePolicy = 'cache-and-network' | 'network-only' | 'cache-first' | 'cache-only';
declare type StandardOperationResult<TData = any> = ExecutionResult<TData>;
declare type QueryVariables = Record<string, any>;
interface ObserverLike<T> {
    next?: (value: T) => void;
    error?: (err: any) => void;
    complete?: () => void;
}
interface Unsubscribable {
    unsubscribe: () => void;
}
/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */
interface ObservableLike<T> {
    subscribe(observer: ObserverLike<T>): Unsubscribable;
}
declare type MaybeRef<T> = T | Ref<T>;
declare type MaybeLazyOrRef<T> = MaybeRef<T> | (() => T);
declare type OperationType = 'query' | 'mutation' | 'subscription';
declare type AfterQueryCallback = (result: OperationResult, ctx: {
    response?: ParsedResponse<unknown>;
}) => void | Promise<void>;
interface OperationWithCachePolicy<TData, TVars> extends Operation<TData, TVars> {
    cachePolicy?: CachePolicy;
}
declare type ClientPluginOperation = OperationWithCachePolicy<unknown, QueryVariables> & {
    type: OperationType;
    key: number;
};
interface QueryExecutionContext {
    headers: Record<string, string>;
}
interface ClientPluginContext {
    useResult: (result: OperationResult<unknown>, terminate?: boolean) => void;
    afterQuery: (cb: AfterQueryCallback) => void;
    operation: ClientPluginOperation;
    opContext: FetchOptions;
    response?: ParsedResponse<unknown>;
}
declare type ClientPlugin = ({ useResult, operation }: ClientPluginContext) => void | Promise<void>;
declare type QueryPredicateOrSignal<TVars = QueryVariables> = boolean | Ref<boolean> | ((variables: TVars) => boolean);

interface ClientOptions {
    url: string;
    cachePolicy?: CachePolicy;
    use?: ClientPlugin[];
}
/**
 * Sets or unsets the active client
 *
 * @param client - villus client instance
 */
declare const setActiveClient: (client: Client | undefined) => Client;
/**
 * Get the currently active client if there is any.
 */
declare const getActiveClient: () => any;
declare type OnResultChangedCallback<TData> = (result: OperationResult<TData>) => unknown;
declare const defaultPlugins: () => ClientPlugin[];
declare class Client {
    install: (app: App) => void;
    private url;
    private defaultCachePolicy;
    private plugins;
    constructor(opts: ClientOptions);
    /**
     * Executes an operation and returns a normalized response.
     */
    private execute;
    executeQuery<TData = any, TVars = QueryVariables>(operation: OperationWithCachePolicy<TData, TVars>, queryContext?: QueryExecutionContext, onResultChanged?: OnResultChangedCallback<TData>): Promise<OperationResult<TData>>;
    executeMutation<TData = any, TVars = QueryVariables>(operation: Operation<TData, TVars>, queryContext?: QueryExecutionContext): Promise<OperationResult<TData>>;
    executeSubscription<TData = any, TVars = QueryVariables>(operation: Operation<TData, TVars>): Promise<ObservableLike<StandardOperationResult<TData>>>;
}
declare function createClient(opts: ClientOptions): Client;

declare function useClient(opts: ClientOptions): Client;

declare function getQueryKey(operation: Operation<unknown, unknown>, ...components: string[]): number;

interface QueryCompositeOptions<TData, TVars> {
    query: MaybeRef<Operation<TData, TVars>['query']>;
    variables?: MaybeLazyOrRef<TVars>;
    context?: MaybeRef<QueryExecutionContext>;
    cachePolicy?: CachePolicy;
    fetchOnMount?: boolean;
    client?: Client;
    paused?: QueryPredicateOrSignal<TVars>;
    skip?: QueryPredicateOrSignal<TVars>;
}
interface QueryExecutionOpts<TVars> {
    cachePolicy: CachePolicy;
    variables: TVars;
}
interface BaseQueryApi<TData = any, TVars = QueryVariables> {
    data: Ref<TData | null>;
    isFetching: Ref<boolean>;
    isDone: Ref<boolean>;
    error: Ref<CombinedError | null>;
    execute(overrideOpts?: Partial<QueryExecutionOpts<TVars>>): Promise<{
        data: TData | null;
        error: CombinedError | null;
    }>;
}
interface QueryApi<TData, TVars> extends BaseQueryApi<TData, TVars> {
    then(onFulfilled: (value: BaseQueryApi<TData, TVars>) => any): Promise<BaseQueryApi<TData, TVars>>;
}
declare function useQuery<TData = any, TVars = QueryVariables>(opts: QueryCompositeOptions<TData, TVars>): QueryApi<TData, TVars>;

interface MutationExecutionOptions {
    context: MaybeRef<QueryExecutionContext>;
    client?: Client;
}
declare function useMutation<TData = any, TVars = QueryVariables>(query: Operation<TData, TVars>['query'], opts?: Partial<MutationExecutionOptions>): {
    data: Ref<TData>;
    isFetching: Ref<boolean>;
    isDone: Ref<boolean>;
    error: Ref<CombinedError>;
    execute: (variables?: TVars) => Promise<{
        data: TData;
        error: CombinedError;
    }>;
};

interface SubscriptionCompositeOptions<TData, TVars> {
    query: MaybeRef<Operation<TData, TVars>['query']>;
    variables?: MaybeRef<TVars>;
    paused?: QueryPredicateOrSignal<TVars>;
    client?: Client;
}
declare type Reducer<TData = any, TResult = TData> = (prev: TResult | null, value: OperationResult<TData>) => TResult;
declare function useSubscription<TData = any, TResult = TData, TVars = QueryVariables>(opts: SubscriptionCompositeOptions<TData, TVars>, reduce?: Reducer<TData, TResult>): {
    data: Ref<vue.UnwrapRef<TResult>>;
    error: Ref<CombinedError>;
    paused: vue.ComputedRef<boolean>;
};

declare type SubscriptionForwarder<TData = any> = (operation: ClientPluginOperation) => ObservableLike<StandardOperationResult<TData>>;
declare function handleSubscriptions(forwarder: SubscriptionForwarder): ClientPlugin;

interface FetchPluginOpts {
    fetch?: typeof window['fetch'];
}
declare function fetch(opts?: FetchPluginOpts): ClientPlugin;

declare function cache(): ClientPlugin;

declare function dedup(): ClientPlugin;

declare function definePlugin(fn: ClientPlugin): ClientPlugin;

declare const VILLUS_CLIENT: InjectionKey<Client>;

export { AfterQueryCallback, BaseQueryApi, CachePolicy, Client, ClientOptions, ClientPlugin, ClientPluginContext, ClientPluginOperation, CombinedError, FetchOptions, GraphQLResponse, MaybeLazyOrRef, MaybeRef, ObservableLike, ObserverLike, Operation, OperationResult, OperationType, OperationWithCachePolicy, ParsedResponse, QueryApi, QueryCompositeOptions, QueryExecutionContext, QueryPredicateOrSignal, QueryVariables, Reducer, StandardOperationResult, SubscriptionForwarder, Unsubscribable, VILLUS_CLIENT, cache, createClient, dedup, defaultPlugins, definePlugin, fetch, getActiveClient, getQueryKey, handleSubscriptions, makeFetchOptions, mergeFetchOpts, parseResponse, setActiveClient, useClient, useMutation, useQuery, useSubscription };
